## Desafio proposto:
____

- Um comerciante precisa controlar o seu fluxo de caixa diÃ¡rio com os lanÃ§amentos
(dÃ©bitos e crÃ©ditos), tambÃ©m precisa de um relatÃ³rio que disponibilize o saldo
diÃ¡rio consolidado.

- Chamarei de EasyCash

## Requisitos de negÃ³cio

- ServiÃ§o que faÃ§a o controle de lanÃ§amentos
- ServiÃ§o do consolidado diÃ¡rio

## Requisitos tÃ©cnicos obrigatÃ³rios
- Deve ser feito usando C#
- Desenho da soluÃ§Ã£o
- Testes
- Boas praticas sÃ£o bem vindas (Design Patterns, PadrÃµes de Arquitetura,
SOLID e etc)

## Requisitos nÃ£o funcionais

- O serviÃ§o de controle de lanÃ§amento nÃ£o deve ficar indisponÃ­vel se o sistema de
consolidado diÃ¡rio cair. 
- Em dias de picos, o serviÃ§o de consolidado diÃ¡rio recebe
50 requisiÃ§Ãµes por segundo, com no mÃ¡ximo 5% de perda de requisiÃ§Ãµes.

# Definindo a tecnologia e arquitetura Para estar de acordo com os requisitos tÃ©cnicos

- A aplicaÃ§Ã£o serÃ¡ em .net core, desenvolvida pra ser stateless e cloud native.
- SerÃ£o dois microsserviÃ§os um para controle de fluxo de caixa e outro para relatÃ³rio.
    - Considerei brevemente deixar ambas na mesma aplicaÃ§Ã£o e separar apenas o banco da dados para atender aos requisitos, mas descartei imediatamente visto que o serviÃ§o de relatÃ³rios nÃ£o precisa escalar na mesma proporÃ§Ã£o da aplicaÃ§Ã£o de fluxo de caixa, apesar de isso nÃ£o ser um problema grande eu posso gerenciar melhor recursos valiosos de maquina.
    - ConsistÃªncia eventual nÃ£o serÃ¡ um problema pra esse tipo de aplicaÃ§Ã£o, visto que a consolidaÃ§Ã£o Ã© diÃ¡ria.
- Para arquitetura eu decidi usar clean architecture, mesmo sempre uma aplicaÃ§Ã£o simples, assim tenho cada camada e responsabilidade bem definida e fica mais fÃ¡cil saber onde estÃ¡ cada coisa pela sua esponsabilidade.
- Para autenticaÃ§Ã£o quero utilizar um servidor de identidade como fonte da verdade para a parte de autenticaÃ§Ã£o
- Para o dominio irei usar DDD (Domain Driven Design), tambÃ©m para fins de organizaÃ§Ã£o, legibilidade e melhor manutenÃ§Ã£o, baixo acoplamento, encapsulamento, testes entre outros benefÃ­cios.
- Junto com o DDD irei utilizar (EDA) (Event driven arquitecture) para disparar eventos, possibilitando integraÃ§Ã£o entre dominios de forma desacoplada e fluxos de dados menos complexos.
- Para os eventos emitidos irei utilizar o pattern transaction outbox, persistindo as mensagens no banco de dados e processando-as fora da requisiÃ§Ã£o original.
- Mesmo sendo uma aplicaÃ§Ã£o simples, pensei em utilizar CQRS para separar o comandos de consultas e assim poder utilizar ef core para comandos e dapper para consultas, acho mais simples de fazer dessa orma, apesar de nÃ£o parecer inicialmente, a medida que as aplicaÃ§Ãµes crescem se torna claro o motivo disso ser uma boa escolha evitando complexidade desnecessÃ¡ria e possibilitando usar bancos de dados e leitura no futuro caso seja necessÃ¡rio.
- Para comunicaÃ§Ã£o entre infraestrutura e aplicaÃ§Ã£o irei utilzar o pattern mediator centralizando a comunicaÃ§Ã£o e promovendo baixo acoplamento entre as camadas.
- A arquitetura definida tambÃ©m Ã© bem fÃ¡cil de se realizar manutenÃ§Ã£o quando se entende os conceitos.

# Definindo o tipo de banco de dados:
- Como Ã© um serviÃ§o que trabalha com valores monetÃ¡rios eu que preciso Ã© de um banco relacional pelo forte acoplamento, ACID e transaÃ§Ãµes.
    - Postgress Ã© a melhor escolha por ser gratuito altamente escalÃ¡vel e muito confiavel, Ã© possivel escalar horizontalmente fazendo sharding e Ã© extesÃ­vel para trabalhar com nosql e full-text-search e timescaledb (bom pra metricas, logs e relatÃ³rios).
- SerÃ¡ uma database para cada aplicaÃ§Ã£o, garantindo assim que alguma indisponibilidade em uma nÃ£o afete a outra.

# Definindo cache e mensageria
- Escolhi o Redis: Defendendo a escolha do redis como ferramenta, ele Ã© amplamente utilizado tendo uma comunidade enorme, Ã© escalÃ¡vel e possui integrado a ele varios recursos que precisamos nesse tipo de aplicaÃ§Ã£o.
- Redis streams para mensageria para garantir resiliÃªncia nas aplicaÃ§Ãµes garantindo que caso tenha alguma indisponibilidade nenhuma mensagem seja perdida e possa ser consumida quando a aplicaÃ§Ã£o voltar a ficar online.
- NÃ£o vejo sentido em cogitar qualquer outra ferramenta para cache distribuido. (definiremos estratÃ©gias de cache posteriormente em cada funcionalidade.)

# Observabilidade

- Vai ser usado o padrÃ£o CNCF OpenTelemetry para escoamento de metricas, logs e traces, o open telemetry Ã© open source, um dos maiores projetos da CNCF junto, nÃ£o Ã© vendor lock-in, pode escoar logs pra qualquer vendor do mercado e Ã© amplamente utilizado .
- Utiliza o aspire dashboard para visualiaÃ§Ã£o. Para abrir o aspire dashboard http://localhost:18888/ e obter o token do log do aspire ``` docker logs easycash-aspire-dashboard ``` procurar por algo como http://0.0.0.0:18888/login?t=0eb9b5e395470399e4d0b06d9bb6e65a onde o ``` 0eb9b5e395470399e4d0b06d9bb6e65a ``` Ã© o token a ser utilizado.

# Design do Software

- ** Estrutura de pastas **
____

# EasyCash Solution

ğŸ“‚ Application
 â”œâ”€ EasyCash.Command
 â””â”€ EasyCash.Query
ğŸ“‚ Infraestructure
 â”œâ”€ ğŸ“‚ Database
 â”‚  â”œâ”€ EasyCash.Command.Store
 â”‚  â””â”€ EasyCash.Query.Store
 â”œâ”€ ğŸ“‚ Api
 â”‚  â”œâ”€ EasyCash.Api
 â”‚  â””â”€ EasyCash.Report.Api
 â””â”€ ğŸ“‚ Integrations
    â”œâ”€ EasyCash.Background.Jobs
    â”œâ”€ EasyCash.Dapper.Provider
    â”œâ”€ EasyCash.HealthCheck.Provider
    â”œâ”€ EasyCash.OpenTelemetry
    â”œâ”€ EasyCash.Redis.Provider
    â”œâ”€ EasyCash.Authentication.Provider
    â””â”€ EasyCash.Authorization.Provider
ğŸ“‚ Domain
 â””â”€ EasyCash.Domain
ğŸ“‚ Tests
 â”œâ”€ EasyCash.ArchitectureTests
 â”œâ”€ EasyCash.Unit.Tests
 â””â”€ EasyCash.Integration.Tests

- Para autenticaÃ§Ã£o e autorizaÃ§Ã£o considerei utilizar o proprio identity jÃ¡ disponÃ­vel no .net core, mas por familiaridade vou utilizar o keycloak
- Entity Framework Core para persistÃªncia de dados
    - ef core migrations para aplicar mudanÃ§as no banco de dados
- Dapper para queries de consulta
- O pacote MediatR estÃ¡ sendo utiliado por ser fÃ¡cil e ter as funcionalidaes que preciso para enviar requisiÃ§Ãµes, eventos e ter os behaviors que usarei para algumas funcionalidades.
- Transaction outbox roda em um job no quarkus em uma cron job
- A aplicaÃ§Ã£o de EasyCash.Api utiliza o database EasyCash e EasyCash.Report.Api irÃ¡ utilizar EasyCash_Report
- utiliza injeÃ§Ã£o de dependencia nativa do .net core
- Health checks no endpoint /health para que o service discovery possa identificar corretamente a aplicaÃ§Ã£o saudavel, verificando acesso a banco de dados, redis e identity provider
- Open


## Diagrama de auto nÃ­vel

-- Assets/diagrama-macro.drawio

![Texto alternativo](assets/macro.jpg)


## Diagrama sequencia requests (sem autenticaÃ§Ã£o/autorizaÃ§Ã£o)
```mermaid
sequenceDiagram
    participant Cliente as Cliente (API)
    participant Controller as Controller (Application Layer)
    participant Mediator as Mediator (MediatR)
    participant Behaviors as Behaviors (Middleware)
    participant CQRS as CQRS Handler
    participant Repository as RepositÃ³rio (Banco de Dados)
    
    Cliente->>Controller: Envia requisiÃ§Ã£o (Command/Query)
    Controller->>Mediator: Envia request para o Mediator
    Mediator->>Behaviors: Passa pelo pipeline de Behaviors
    Behaviors->>CQRS: Encaminha para o Handler correto
    CQRS-->>Repository: (Se for comando persiste) (se for query lÃª) no banco
    Repository-->>CQRS: Retorna sucesso/erro
    CQRS-->>Behaviors: Retorna resposta
    Behaviors-->>Mediator: Continua fluxo
    Mediator-->>Controller: Retorna resposta
    Controller-->>Cliente: Envia resposta final

```


## Diagrama sequencia UnitOfWork
```mermaid
sequenceDiagram
    participant Cliente as Cliente (API)
    participant Controller as Controller (Application Layer)
    participant Mediator as Mediator (MediatR)
    participant TransactionalBehavior as Transactional Behavior (UnitOfWork)
    participant CQRS as Command Handler
    participant UnitOfWork as UnitOfWork
    participant EfCore as Ef Core
    participant Repository as Banco de Dados
    
    Cliente->>Controller: Envia requisiÃ§Ã£o (Command)
    Controller->>Mediator: Envia request para o Mediator
    Mediator->>TransactionalBehavior: Passa pelo TransactionalBehavior
    TransactionalBehavior->>UnitOfWork: Inicia transaÃ§Ã£o
    TransactionalBehavior->>CQRS: Chama o Handler correto
    CQRS-->>EfCore: Persiste dados
    EfCore-->>CQRS: Retorna sucesso/erro
    CQRS-->>TransactionalBehavior: Retorna resultado da operaÃ§Ã£o
    TransactionalBehavior->>UnitOfWork: Chama SaveChanges e Commit
    UnitOfWork->>Repository: Persiste dados
    Repository-->>TransactionalBehavior: Confirma sucesso
    TransactionalBehavior-->>Mediator: Continua fluxo
    Mediator-->>Controller: Retorna resposta
    Controller-->>Cliente: Envia resposta final

```

## Diagrama outbox

```mermaid
sequenceDiagram
    participant Aplicacao as AplicaÃ§Ã£o
    participant UnitOfWork as UnitOfWork
    participant Outbox as Outbox Messages (DB)
    participant CronJob as Cron Job
    participant Handler as Event Handler

    Aplicacao->>UnitOfWork: Salvar entidade e publicar eventos
    UnitOfWork-->>Aplicacao: ConfirmaÃ§Ã£o da operaÃ§Ã£o
    UnitOfWork->>Outbox: Salva eventos serializados na Outbox

    CronJob->>Outbox: Consulta eventos nÃ£o processados
    Outbox-->>CronJob: Retorna eventos pendentes
    CronJob->>Handler: Dispara evento para o handler correspondente
    Handler-->>CronJob: Confirma processamento do evento
    CronJob->>Outbox: Marca evento como processado

```

## Diagrama de chamadas com idempotencia

```mermaid
sequenceDiagram
    participant Cliente as Cliente (API)
    participant Mediator as Mediator (MediatR)
    participant IdempotencyBehavior as IdempotencyBehavior
    participant Redis as Redis (Idempotency Store)
    participant CQRS as Command Handler
    
    Cliente->>Mediator: Envia requisiÃ§Ã£o (Command)
    Mediator->>IdempotencyBehavior: Passa pelo IdempotencyBehavior
    IdempotencyBehavior->>Redis: Verifica idempotencyKey
    alt Chave jÃ¡ existe
        Redis-->>IdempotencyBehavior: Retorna resposta salva
        IdempotencyBehavior-->>Mediator: Retorna resposta
        Mediator-->>Cliente: Envia resposta final
    else Nova requisiÃ§Ã£o
        Redis-->>IdempotencyBehavior: NÃ£o encontrado, continua fluxo
        IdempotencyBehavior->>CQRS: Chama o Handler correto
        CQRS-->>IdempotencyBehavior: Retorna resultado
        IdempotencyBehavior-->>Mediator: Continua fluxo
        Mediator-->>Cliente: Envia resposta final
    end

```

## ConsideraÃ§Ãµes adicionais
- Backup dos bancos de dados, definir frequencia e estratÃ©gias.
- Penso em estratÃ©gias de retry para consumo de mensagens que eventualmente ocorrerem problemas aplicando conceito de dead letter queues e retry com backoff exponencial, nÃ£o irei fazer isso nesse teste devido a complexidade.
- Criar pipeline CI
- Criar IaaS (infraestrutura como serviÃ§o) para implantaÃ§Ã£o e mudanÃ§as de forma rÃ¡pidas e consistentes.
- Adicionar variaveis de ambientes e vault para senhas e secrets